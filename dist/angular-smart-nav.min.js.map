{"version":3,"sources":["?","../app/js/smartNav.js"],"names":["window","angular","module","constant","scrollingUp","scrollingDown","minimise","affix","directive","$window","$document","SN_SMART_NAV_CLASSES","restrict","link","$scope","$element","lastScrollTop","getScrollTop","doc","documentElement","body","scrollTop","positionFromTop","getBoundingClientRect","top","isScrollingDown","currentScrollTop","isScrollingUp","calScrollDir","removeClass","addClass","calMinimisedMode","offsetHeight","calAffixedMode","onScroll","onDestroy","element","off","$on","on"],"mappings":";;CAAA,SAAUA,GCAV,YAuBAC,SAAQC,OAAO,kBAOdC,SAAS,wBACRC,YAAa,sBACbC,cAAe,wBACfC,SAAU,kBACVC,MAAO,iBAURC,UAAU,cACT,UACA,YACA,uBACA,SAAUC,EAASC,EAAWC,GAC5B,OACEC,SAAU,IACVC,KAAM,SAASC,EAAQC,GAOrB,GAAIC,GAAgB,EAOhBX,GAAgB,EAMhBY,EAAe,WACjB,GAAIC,GAAMR,EAAU,GAAGS,gBACnBC,EAAOV,EAAU,GAAGU,KACpBC,EAAeH,GAAOA,EAAIG,WAAeD,GAAQA,EAAKC,WAAc,CAExE,OAAOA,IAMLC,EAAmBL,IAAiBF,EAAS,GAAGQ,wBAAwBC,IAOxEC,EAAkB,SAAyBC,GAC7C,MAAOA,GAAmBV,GAQxBW,EAAgB,SAAuBD,GACzC,MAA0BV,GAAnBU,GAQLE,EAAe,SAAsBP,GAClChB,GAAiBsB,EAAcN,IAClChB,GAAgB,EAChBU,EAASc,YAAYlB,EAAqBN,eAC1CU,EAASe,SAASnB,EAAqBP,eAC5BC,GAAiBoB,EAAgBJ,KAC5ChB,GAAgB,EAChBU,EAASc,YAAYlB,EAAqBP,aAC1CW,EAASe,SAASnB,EAAqBN,iBASvC0B,EAAmB,SAA0BV,GAC3CA,EAAYN,EAAS,GAAGiB,aAC1BjB,EAASe,SAASnB,EAAqBL,UAEvCS,EAASc,YAAYlB,EAAqBL,WAS1C2B,EAAiB,SAAwBZ,GACvCA,GAAaC,EACfP,EAASe,SAASnB,EAAqBJ,OAEvCQ,EAASc,YAAYlB,EAAqBJ,QAU1C2B,EAAW,WACb,GAAIb,GAAYJ,GAEhBW,GAAaP,GACbU,EAAiBV,GACjBY,EAAeZ,GAEfL,EAAgBK,GAMdc,EAAY,WACdlC,QAAQmC,QAAQ3B,GAAS4B,IAAI,SAAUH,GAGzCpB,GAAOwB,IAAI,WAAYH,GACvBlC,QAAQmC,QAAQ3B,GAAS8B,GAAG,SAAUL,GAEtCA,UD3KuBlC","file":"angular-smart-nav.min.js","sourcesContent":[null,"'use strict';\n/**\n * Module that detects the last scroll direction and\n * current scroll position to then add classes for\n * when the user is scrolling up or down the page\n * to show/hide the nav when scrolling in any particular\n * direction. Also when the user has scrolled beyond the\n * height of header adds a class to allow the nav to be\n * minimized or hidden.\n *\n * When the user has scrolled down the page the class\n * `sn-nav-scrolling-down` will be added, when scrolling up\n * `sn-nav-scrolling-up`. If the user has scrolled beyond the\n * height of the nav the class `sn-nav-minimise`.\n *\n * If the element is at the top of the viewport or above\n * it then the class `sn-nav-affix` will be added. This is useful\n * for making an element sticky when user has scrolled to it\n *\n * @module   sn.smartNav\n * @main     sn.smartNav\n * @author   SOON_\n */\nangular.module('sn.smartNav', [\n\n])\n/**\n * Contains all css class names\n * @property {Object} SN_SMART_NAV_CLASSES\n */\n.constant('SN_SMART_NAV_CLASSES', {\n  scrollingUp: 'sn-nav-scrolling-up',\n  scrollingDown: 'sn-nav-scrolling-down',\n  minimise: 'sn-nav-minimise',\n  affix: 'sn-nav-affix'\n})\n/**\n * @example\n *  `<nav sn-smart-nav></nav>`\n * @class   snSmartNav\n * @param   {Service} $window   : Angular.js wrapper for window Object\n * @param   {Service} $document : Angular.js wrapper for document Object\n * @param   {Object}  SN_SMART_NAV_CLASSES : Angular.js wrapper for document Object\n */\n.directive('snSmartNav',[\n  '$window',\n  '$document',\n  'SN_SMART_NAV_CLASSES',\n  function ($window, $document, SN_SMART_NAV_CLASSES){\n    return {\n      restrict: 'A',\n      link: function($scope, $element){\n        /**\n         * The last recorded scrollTop position\n         * @private\n         * @property lastScrollTop\n         * @type     {Number}\n         */\n        var lastScrollTop = 0;\n        /**\n         * True if the last scroll direction was down the page\n         * @private\n         * @property scrollingDown\n         * @type     {Boolean}\n         */\n        var scrollingDown = false;\n        /**\n         * @method getScrollTop\n         * @returns {Number} the number of pixel from top of\n         *                   page the user has scrolled\n         */\n        var getScrollTop = function getScrollTop() {\n          var doc = $document[0].documentElement,\n              body = $document[0].body,\n              scrollTop = ( (doc && doc.scrollTop) || (body && body.scrollTop) || 0 );\n\n          return scrollTop;\n        };\n        /**\n         * The number of pixels from the top of the page\n         * @property {Number} positionFromTop\n         */\n        var positionFromTop = (getScrollTop() + $element[0].getBoundingClientRect().top);\n        /**\n         * @method isScrollingDown\n         * @private\n         * @param  {Number}  currentScrollTop\n         * @return {Boolean} True if last scroll direction is down\n         */\n        var isScrollingDown = function isScrollingDown(currentScrollTop){\n          return currentScrollTop > lastScrollTop;\n        };\n        /**\n         * @method isScrollingUp\n         * @private\n         * @param  {Number}  currentScrollTop\n         * @return {Boolean} True if last scroll direction is up\n         */\n        var isScrollingUp = function isScrollingUp(currentScrollTop){\n          return currentScrollTop < lastScrollTop;\n        };\n        /**\n         * Calulate the current scroll direction and add relevent classes\n         * @private\n         * @method calScrollDir\n         * @param  {Number} scrollTop\n         */\n        var calScrollDir = function calScrollDir(scrollTop){\n          if ( scrollingDown && isScrollingUp(scrollTop) ) {\n            scrollingDown = false;\n            $element.removeClass(SN_SMART_NAV_CLASSES.scrollingDown);\n            $element.addClass(SN_SMART_NAV_CLASSES.scrollingUp);\n          } else if ( !scrollingDown && isScrollingDown(scrollTop) ){\n            scrollingDown = true;\n            $element.removeClass(SN_SMART_NAV_CLASSES.scrollingUp);\n            $element.addClass(SN_SMART_NAV_CLASSES.scrollingDown);\n          }\n        };\n        /**\n         * Calulate if the user has scrolled beyond the height of the element\n         * @private\n         * @method calMinimisedMode\n         * @param  {Number}  scrollTop\n         */\n        var calMinimisedMode = function calMinimisedMode(scrollTop){\n          if (scrollTop > $element[0].offsetHeight) {\n            $element.addClass(SN_SMART_NAV_CLASSES.minimise);\n          } else {\n            $element.removeClass(SN_SMART_NAV_CLASSES.minimise);\n          }\n        };\n        /**\n         * Calulate if the element is at top or above viewport\n         * so we can 'affix' it to top of the viewport.\n         * @private\n         * @method calAffixedMode\n         */\n        var calAffixedMode = function calAffixedMode(scrollTop){\n          if (scrollTop >= positionFromTop ) {\n            $element.addClass(SN_SMART_NAV_CLASSES.affix);\n          } else {\n            $element.removeClass(SN_SMART_NAV_CLASSES.affix);\n          }\n        };\n        /**\n         * window `scroll` event handler.\n         * Gets the current scroll postion and calulates\n         * scroll direction and whether to enable minimise mode\n         * @private\n         * @method onScroll\n         */\n        var onScroll = function onScroll() {\n          var scrollTop = getScrollTop();\n\n          calScrollDir(scrollTop);\n          calMinimisedMode(scrollTop);\n          calAffixedMode(scrollTop);\n\n          lastScrollTop = scrollTop;\n        };\n        /**\n         * Clear event listeners\n         * @method onDestroy\n         */\n        var onDestroy = function onDestroy(){\n          angular.element($window).off('scroll', onScroll);\n        };\n\n        $scope.$on('$destroy', onDestroy);\n        angular.element($window).on('scroll', onScroll);\n\n        onScroll();\n      }\n    };\n  }\n]);\n"]}